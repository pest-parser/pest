use futures::{Async, Poll};
use futures::stream::Stream;
use futures::sync::mpsc::UnboundedReceiver;

use super::parsing_error::ParsingError;
use super::token::Token;

/// A `Stream` of `Token` objects generated by the `Parser`.
pub struct TokenStream<Rule> {
    receiver: UnboundedReceiver<Result<Token<Rule>, ParsingError>>
}

impl<Rule> TokenStream<Rule> {
    /// Creates a new `TokenStream` from a `Token`-generating `UnboundedReceiver`.
    ///
    /// # Examples
    ///
    /// ```
    /// # extern crate futures;
    /// # extern crate pest;
    /// # use futures::sync::mpsc::unbounded;
    /// # use pest::{ParsingError, Token, TokenStream};
    /// # fn main() {
    /// let (_, r) = unbounded::<Result<Token<()>, ParsingError>>();
    ///
    /// let stream = TokenStream::new(r);
    /// # }
    /// ```
    pub fn new(receiver: UnboundedReceiver<Result<Token<Rule>, ParsingError>>)
        -> TokenStream<Rule> {

        TokenStream {
            receiver: receiver
        }
    }
}

impl<Rule> Stream for TokenStream<Rule> {
    type Item  = Token<Rule>;
    type Error = ParsingError;

    fn poll(&mut self) -> Poll<Option<Token<Rule>>, ParsingError> {
        match self.receiver.poll() {
            Ok(Async::Ready(Some(result))) => {
                match result {
                    Ok(token)  => Ok(Async::Ready(Some(token))),
                    Err(error) => Err(error)
                }
            },
            Ok(Async::Ready(None)) => Ok(Async::Ready(None)),
            Ok(Async::NotReady)    => Ok(Async::NotReady),
            Err(_)                 => unreachable!()
        }
    }
}
