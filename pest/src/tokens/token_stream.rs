use futures::{Async, Poll};
use futures::stream::Stream;

use super::super::error::Error;
use super::super::tokens::Token;

/// A `Stream` of `Token` objects generated by the `Parser`.
pub struct TokenStream<Rule, S>
    where S: Stream<Item=Result<Token<Rule>, Error<Rule>>, Error=()> {

    stream: S
}

impl<Rule, S> TokenStream<Rule, S>
    where S: Stream<Item=Result<Token<Rule>, Error<Rule>>, Error=()> {

    /// Creates a new `TokenStream` from a `Token`-generating `UnboundedReceiver`.
    ///
    /// # Examples
    ///
    /// ```
    /// # extern crate futures;
    /// # extern crate pest;
    /// # use futures::sync::mpsc::unbounded;
    /// # use pest::Error;
    /// # use pest::tokens::{Token, TokenStream};
    /// # fn main() {
    /// let (_, r) = unbounded::<Result<Token<()>, Error<()>>>();
    ///
    /// let stream = TokenStream::new(r);
    /// # }
    /// ```
    pub fn new(stream: S) -> TokenStream<Rule, S> {

        TokenStream {
            stream: stream
        }
    }
}

impl<Rule, S> Stream for TokenStream<Rule, S>
    where S: Stream<Item=Result<Token<Rule>, Error<Rule>>, Error=()> {
    type Item  = Token<Rule>;
    type Error = Error<Rule>;

    fn poll(&mut self) -> Poll<Option<Token<Rule>>, Error<Rule>> {
        match self.stream.poll() {
            Ok(Async::Ready(Some(result))) => {
                match result {
                    Ok(token)  => Ok(Async::Ready(Some(token))),
                    Err(error) => Err(error)
                }
            },
            Ok(Async::Ready(None)) => Ok(Async::Ready(None)),
            Ok(Async::NotReady)    => Ok(Async::NotReady),
            Err(_)                 => unreachable!()
        }
    }
}
