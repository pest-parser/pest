use futures::{Async, Poll};
use futures::stream::Stream;
use futures::sync::mpsc::UnboundedReceiver;

use super::super::error::Error;
use super::super::tokens::Token;

/// A `Stream` of `Token` objects generated by the `Parser`.
pub struct ParserStream<Rule> {
    receiver: UnboundedReceiver<Result<Token<Rule>, Error<Rule>>>
}

pub fn new<Rule>(receiver: UnboundedReceiver<Result<Token<Rule>, Error<Rule>>>) -> ParserStream<Rule> {
    ParserStream {
        receiver: receiver
    }
}

impl<Rule> Stream for ParserStream<Rule> {
    type Item  = Token<Rule>;
    type Error = Error<Rule>;

    fn poll(&mut self) -> Poll<Option<Token<Rule>>, Error<Rule>> {
        match self.receiver.poll() {
            Ok(Async::Ready(Some(result))) => {
                match result {
                    Ok(token)  => Ok(Async::Ready(Some(token))),
                    Err(error) => Err(error)
                }
            },
            Ok(Async::Ready(None)) => Ok(Async::Ready(None)),
            Ok(Async::NotReady)    => Ok(Async::NotReady),
            Err(_)                 => unreachable!()
        }
    }
}
